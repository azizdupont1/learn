import os
import psycopg2
import hmac
import hashlib
from cryptography.fernet import Fernet
import pandas as pd
import json


class EncryptionHandler:
    def __init__(self, db_params, mapping_file="mapping.enc"):
        self.db_params = db_params
        self.mapping_file = mapping_file
        self._ensure_table_exists()  # V√©rifier et cr√©er la table si n√©cessaire
        self.cipher_suite, self.hmac_key = self._get_keys()

    def _ensure_table_exists(self):
        """V√©rifie et cr√©e la table encryption_keys si elle n'existe pas"""
        try:
            with psycopg2.connect(**self.db_params) as conn:
                with conn.cursor() as cur:
                    cur.execute("""
                        CREATE TABLE IF NOT EXISTS encryption_keys (
                            id SERIAL PRIMARY KEY,
                            key_name VARCHAR(255) NOT NULL UNIQUE,
                            key_value BYTEA NOT NULL,
                            created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
                        );
                    """)
                    conn.commit()
            print("‚úÖ Table encryption_keys v√©rifi√©e/cr√©√©e avec succ√®s.")
        except Exception as e:
            print(f"‚ùå Erreur lors de la cr√©ation de la table encryption_keys : {e}")
            raise

    def _get_keys(self):
        """R√©cup√®re ou g√©n√®re les cl√©s de chiffrement et HMAC"""
        try:
            with psycopg2.connect(**self.db_params) as conn:
                with conn.cursor() as cur:
                    cur.execute("SELECT key_name, key_value FROM encryption_keys WHERE key_name IN ('FERNET_KEY', 'HMAC_KEY');")
                    keys = {row[0]: row[1] for row in cur.fetchall()}

                    if "FERNET_KEY" in keys and "HMAC_KEY" in keys:
                        print("‚úÖ Utilisation des cl√©s existantes.")
                        fernet_key = keys["FERNET_KEY"]
                        hmac_key = keys["HMAC_KEY"]
                    else:
                        print("üîë G√©n√©ration de nouvelles cl√©s...")
                        fernet_key = Fernet.generate_key()
                        hmac_key = os.urandom(32)

                        cur.execute("""
                            INSERT INTO encryption_keys (key_name, key_value) 
                            VALUES (%s, %s)
                            ON CONFLICT (key_name) DO UPDATE SET key_value = EXCLUDED.key_value;
                        """, ("FERNET_KEY", psycopg2.Binary(fernet_key)))
                        
                        cur.execute("""
                            INSERT INTO encryption_keys (key_name, key_value) 
                            VALUES (%s, %s)
                            ON CONFLICT (key_name) DO UPDATE SET key_value = EXCLUDED.key_value;
                        """, ("HMAC_KEY", psycopg2.Binary(hmac_key)))

                        conn.commit()
                        print("‚úÖ Cl√©s enregistr√©es en base de donn√©es.")

            return Fernet(fernet_key), hmac_key

        except Exception as e:
            print(f"‚ùå Erreur lors de la r√©cup√©ration des cl√©s : {e}")
            raise

    def encrypt(self, data):
        """Chiffre une donn√©e en texte clair"""
        try:
            return self.cipher_suite.encrypt(data.encode()).decode()
        except Exception as e:
            print(f"‚ùå Erreur lors du chiffrement : {e}")
            return None

    def decrypt(self, data):
        """D√©chiffre une donn√©e chiffr√©e"""
        try:
            return self.cipher_suite.decrypt(data.encode()).decode()
        except Exception as e:
            print(f"‚ùå Erreur lors du d√©chiffrement : {e}")
            return None

    def hash_hmac(self, data):
        """Hache une donn√©e avec HMAC-SHA256"""
        try:
            key_bytes = bytes(self.hmac_key) if isinstance(self.hmac_key, memoryview) else self.hmac_key
            hmac_hash = hmac.new(key_bytes, data.encode(), hashlib.sha256)
            return hmac_hash.hexdigest()
        except Exception as e:
            print(f"‚ùå Erreur lors du hachage HMAC : {e}")
            return None

        
        


class DataAnonymizer:
    def __init__(self, encryption_handler):
        self.encryption = encryption_handler
        self.mapping_tables = {"nc": {}, "id_etu": {}, "code_ecol": {}}
        self._load_mapping()

    def _load_mapping(self):
        """Charge les mappings d'anonymisation si le fichier existe"""
        try:
            # V√©rifie si le fichier existe
            if os.path.exists(self.encryption.mapping_file):
                print("Le fichier mapping.enc existe.")
                with open(self.encryption.mapping_file, "rb") as f:
                    encrypted_mapping = f.read()
                    print(f"Lecture du fichier mapping.enc r√©ussie, taille du fichier : {len(encrypted_mapping)} bytes")
                    
                    # D√©cryptage du fichier
                    decrypted_mapping = self.encryption.cipher_suite.decrypt(encrypted_mapping).decode()
                    print("Mapping d√©chiffr√© avec succ√®s.")
                    
                    # Chargement du mapping JSON
                    try:
                        self.mapping_tables = json.loads(decrypted_mapping)
                        #print("Mapping charg√© :", self.mapping_tables)  # Affiche pour v√©rifier la structure
                    except json.JSONDecodeError as e:
                        print(f"‚ùå Erreur de d√©codage JSON : {str(e)}")
                        raise
            else:
                print("Le fichier mapping.enc n'existe pas.")
        except Exception as e:
            print(f"‚ùå Erreur lors du chargement du mapping : {str(e)}")
            raise  # Re-lancer l'exception pour plus de d√©tails dans la trace

    def _save_mapping(self):
        """Sauvegarde le mapping d'anonymisation dans un fichier chiffr√© uniquement si le fichier n'existe pas"""
        try:
            # V√©rifie si le fichier de mapping existe d√©j√†
            if not os.path.exists(self.encryption.mapping_file):
                with open(self.encryption.mapping_file, "wb") as f:
                    encrypted_mapping = self.encryption.cipher_suite.encrypt(json.dumps(self.mapping_tables).encode())
                    f.write(encrypted_mapping)
                print("Mapping d'anonymisation sauvegard√© avec succ√®s.")
            else:
                print("Le fichier mapping.enc existe d√©j√†. Il ne sera pas r√©√©crit.")
        except Exception as e:
            print(f"‚ùå Erreur lors de la sauvegarde du mapping : {e}")

    def anonymize_dataframe(self, df):
        """Anonymise un DataFrame en chiffrant certains champs et en anonymisant d'autres"""

        required_columns = ["nc", "id_etu", "nom_etu", "code_ecol", "nom_ecol"]
        if not all(column in df.columns for column in required_columns):
            raise ValueError(f"Le DataFrame doit contenir les colonnes suivantes : {required_columns}")

        df_anonymized = df.copy()

        # Hacher les colonnes nc, id_etu et code_ecol
        for column in ["nc", "id_etu", "code_ecol"]:
            df_anonymized[column] = df[column].apply(lambda x: self.mapping_tables[column].setdefault(x, self.encryption.hash_hmac(x)))

        # Chiffrer les colonnes nom_etu et nom_ecol
        df_anonymized["nom_etu"] = df["nom_etu"].apply(self.encryption.encrypt)
        df_anonymized["nom_ecol"] = df["nom_ecol"].apply(self.encryption.encrypt)

        # Sauvegarder le mapping seulement si n√©cessaire
        self._save_mapping()

        return df_anonymized
    
    
    

class DataDeanonymizer:
    def __init__(self, encryption_handler, mapping_file_path=None):
        self.encryption = encryption_handler
        self.mapping_file_path = mapping_file_path or self.encryption.mapping_file
        self.mapping_tables = {"nc": {}, "id_etu": {}, "code_ecol": {}}
        self._load_mapping()

    def _load_mapping(self):
        """Charge les mappings d'anonymisation si le fichier existe"""
        try:
            if os.path.exists(self.mapping_file_path):
                print(f"Le fichier mapping.enc existe √† {self.mapping_file_path}.")
                with open(self.mapping_file_path, "rb") as f:
                    encrypted_mapping = f.read()
                    print(f"Lecture du fichier mapping.enc r√©ussie, taille du fichier : {len(encrypted_mapping)} bytes")
                    
                    # D√©cryptage du fichier
                    decrypted_mapping = self.encryption.cipher_suite.decrypt(encrypted_mapping).decode()
                    print("Mapping d√©chiffr√© avec succ√®s.")
                    
                    # Chargement du mapping JSON
                    try:
                        self.mapping_tables = json.loads(decrypted_mapping)
                        print("Mapping charg√© :", self.mapping_tables)
                    except json.JSONDecodeError as e:
                        print(f"‚ùå Erreur de d√©codage JSON : {str(e)}")
                        raise
            else:
                print("Le fichier mapping.enc n'existe pas.")
        except Exception as e:
            print(f"‚ùå Erreur lors du chargement du mapping : {str(e)}")
            raise  

    def read_dataframe(self, file_path):
        """Lit un DataFrame en fonction de l'extension du fichier"""
        extension = file_path.split('.')[-1].lower()
        if extension == 'csv':
            return pd.read_csv(file_path)
        elif extension == 'txt':
            return pd.read_csv(file_path, delimiter='\t')  # Pour les fichiers .txt avec tabulation comme s√©parateur
        elif extension == 'xlsx':
            return pd.read_excel(file_path)
        elif extension == 'parquet':
            return pd.read_parquet(file_path)
        else:
            raise ValueError(f"Format de fichier non support√© : {extension}")

    def deanonymize_dataframe(self, df_anonymized):
        """D√©sanonymise un DataFrame en rempla√ßant les valeurs anonymis√©es par les originales"""
        df_deanonymized = df_anonymized.copy()

        # D√©chiffrer les colonnes 'nom_etu' et 'nom_ecol'
        df_deanonymized["nom_etu"] = df_anonymized["nom_etu"].apply(self.encryption.decrypt)
        df_deanonymized["nom_ecol"] = df_anonymized["nom_ecol"].apply(self.encryption.decrypt)

        # D√©sanonymiser les colonnes 'nc', 'id_etu' et 'code_ecol'
        for column in ["nc", "id_etu", "code_ecol"]:
            if column in df_deanonymized.columns:
                reverse_mapping_table = {v: k for k, v in self.mapping_tables[column].items()}
                df_deanonymized[column] = df_anonymized[column].map(reverse_mapping_table)
                print(f"‚úÖ D√©sanonymisation appliqu√©e sur {column}")

        print("üîé DataFrame apr√®s d√©sanonymisation :")
        print(df_deanonymized.head())  # Afficher un aper√ßu du DataFrame d√©sanonymis√©

        return df_deanonymized

    
    
 ########### exemple meme dossier
if __name__ == "__main__":
    db_params = {
        "dbname": "secure_keys_db",
        "user": "postgres",
        "password": "admin",
        "host": "localhost",
        "port": "5432"
    }

    # Initialisation des handlers
    encryption_handler = EncryptionHandler(db_params)
    anonymizer = DataAnonymizer(encryption_handler)
    deanonymizer = DataDeanonymizer(encryption_handler)  # Cr√©er une instance de DataDeanonymizer

    # Exemple de DataFrame
    df = pd.DataFrame({
        "nc": ["12345", "67890"],
        "id_etu": ["abc123", "def456"],
        "nom_etu": ["Jean Dupont", "Marie Curie"],
        "code_ecol": ["AG1", "AG2"],
        "nom_ecol": ["Agence A", "Agence B"]
    })

    print("\n‚úÖ Avant anonymisation :")
    print(df)

    # Anonymisation
    df_anonymized = anonymizer.anonymize_dataframe(df)
    print("\nüîí Apr√®s anonymisation :")
    print(df_anonymized)
    df_anonymized.to_csv("df_anonymized.csv",index=False,sep=';')
    
    # D√©sanonymisation
    df_deanonymized = deanonymizer.deanonymize_dataframe(df_anonymized)  # Utiliser l'instance de DataDeanonymizer pour la d√©sanonymisation
    
    # Exemple d'utilisation avec un chemin de fichier personnalis√©
    custom_mapping_path = "folder_ano_db/mapping.enc"  # Sp√©cifiez le chemin de votre choix
    deanonymizer = DataDeanonymizer(encryption_handler, mapping_file_path=custom_mapping_path)

    print("\nüîì Apr√®s d√©sanonymisation :")
    print(df_deanonymized)

    
    
  
    # un autre repertoitre
    import os
print(os.listdir("folder_ano_db"))
import os
import json
import pandas as pd

import sys
sys.path.append("folder_ano_db")  # S'assurer que Python trouve le fichier
from ano_db1 import DataDeanonymizer, EncryptionHandler  # V√©rifie que l'import est correct

db_params = {
        "dbname": "secure_keys_db",
        "user": "postgres",
        "password": "admin",
        "host": "localhost",
        "port": "5432"
    }

    # Initialisation des handlers
encryption_handler = EncryptionHandler(db_params)
deanonymizer = DataDeanonymizer(encryption_handler)  # Cr√©er une instance de DataDeanonymizer

# D√©sanonymisation
df_anonymized = pd.read_csv("folder_ano_db/df_anonymized.csv",sep=';')
custom_mapping_path = "folder_ano_db/mapping.enc"  # Sp√©cifiez le chemin de votre choix*

deanonymizer = DataDeanonymizer(encryption_handler, mapping_file_path=custom_mapping_path)
# D√©sanonymisation du DataFrame
df_deanonymized = deanonymizer.deanonymize_dataframe(df_anonymized)

# Affichage du r√©sultat apr√®s d√©sanonymisation
print("\nüîì Apr√®s d√©sanonymisation :")
print(df_deanonymized)


_______________________________________________________
import os
import psycopg2
import hashlib
import hmac
from cryptography.fernet import Fernet
from dotenv import load_dotenv

class EncryptionHandler:
    def __init__(self, mapping_file="mapping.enc"):
        self.db_params = self._load_db_params()
        self.mapping_file = mapping_file
        self.cipher_suite, self.hmac_key = self._get_keys()

    def _load_db_params(self):
        """Charge les param√®tres de connexion √† la base de donn√©es depuis un fichier .env"""
        load_dotenv(dotenv_path='folder_ano_db/.env')
        return {
            "dbname": os.getenv("DB_NAME"),
            "user": os.getenv("DB_USER"),
            "password": os.getenv("DB_PASSWORD"),
            "host": os.getenv("DB_HOST"),
            "port": os.getenv("DB_PORT")
        }

    def _get_keys(self):
        """R√©cup√®re ou g√©n√®re les cl√©s de chiffrement et HMAC"""
        try:
            with psycopg2.connect(**self.db_params) as conn:
                with conn.cursor() as cur:
                    # V√©rifier si la table existe
                    cur.execute("""
                        SELECT EXISTS (
                            SELECT FROM information_schema.tables 
                            WHERE table_name = 'encryption_keys'
                        );
                    """)
                    table_exists = cur.fetchone()[0]
                    
                    if not table_exists:
                        print("üîß Cr√©ation de la table encryption_keys...")
                        cur.execute("""
                            CREATE TABLE encryption_keys (
                                id SERIAL PRIMARY KEY,
                                key_name VARCHAR(255) NOT NULL UNIQUE,
                                key_value BYTEA NOT NULL,
                                created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
                            );
                        """)
                        conn.commit()
                        print("‚úÖ Table encryption_keys cr√©√©e avec succ√®s.")
                    
                    # R√©cup√©ration des cl√©s existantes
                    cur.execute("""
                        SELECT key_name, key_value FROM encryption_keys 
                        WHERE key_name IN ('FERNET_KEY', 'HMAC_KEY');
                    """)
                    keys = {row[0]: row[1] for row in cur.fetchall()}
                    
                    if "FERNET_KEY" in keys and "HMAC_KEY" in keys:
                        print("‚úÖ Utilisation des cl√©s existantes.")
                        fernet_key = keys["FERNET_KEY"]
                        hmac_key = keys["HMAC_KEY"]
                    else:
                        print("üîë G√©n√©ration de nouvelles cl√©s...")
                        fernet_key = Fernet.generate_key()
                        hmac_key = os.urandom(32)

                        cur.execute("""
                            INSERT INTO encryption_keys (key_name, key_value) 
                            VALUES (%s, %s)
                            ON CONFLICT (key_name) DO UPDATE SET key_value = EXCLUDED.key_value;
                        """, ("FERNET_KEY", psycopg2.Binary(fernet_key)))

                        cur.execute("""
                            INSERT INTO encryption_keys (key_name, key_value) 
                            VALUES (%s, %s)
                            ON CONFLICT (key_name) DO UPDATE SET key_value = EXCLUDED.key_value;
                        """, ("HMAC_KEY", psycopg2.Binary(hmac_key)))

                        conn.commit()
                        print("‚úÖ Cl√©s enregistr√©es en base de donn√©es.")

            return Fernet(fernet_key), hmac_key

        except Exception as e:
            print(f"‚ùå Erreur lors de la r√©cup√©ration des cl√©s : {e}")
            raise

    def encrypt(self, data):
        """Chiffre une donn√©e en texte clair"""
        try:
            return self.cipher_suite.encrypt(data.encode()).decode()
        except Exception as e:
            print(f"‚ùå Erreur lors du chiffrement : {e}")
            return None

    def decrypt(self, data):
        """D√©chiffre une donn√©e chiffr√©e"""
        try:
            return self.cipher_suite.decrypt(data.encode()).decode()
        except Exception as e:
            print(f"‚ùå Erreur lors du d√©chiffrement : {e}")
            return None

    def hash_hmac(self, data):
        """Hache une donn√©e avec HMAC-SHA256"""
        try:
            key_bytes = bytes(self.hmac_key) if isinstance(self.hmac_key, memoryview) else self.hmac_key
            hmac_hash = hmac.new(key_bytes, data.encode(), hashlib.sha256)
            return hmac_hash.hexdigest()
        except Exception as e:
            print(f"‚ùå Erreur lors du hachage HMAC : {e}")
            return None

