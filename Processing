Voici le script mis √† jour avec les modifications demand√©es, en 
```python
import psycopg2
from psycopg2 import sql
import os
from cryptography.fernet import Fernet
from dotenv import load_dotenv

# Charger les variables d'environnement
load_dotenv()

# Connexion √† PostgreSQL
DB_PARAMS = {
    "dbname": os.getenv("DB_NAME"),
    "user": os.getenv("DB_USER"),
    "password": os.getenv("DB_PASSWORD"),
    "host": os.getenv("DB_HOST"),
    "port": os.getenv("DB_PORT"),
}

def create_db_and_table():
    conn = psycopg2.connect(**DB_PARAMS)
    cursor = conn.cursor()

    # Cr√©ation de la table pour stocker les cl√©s chiffr√©es
    cursor.execute("""
        CREATE TABLE IF NOT EXISTS encryption_keys (
            id SERIAL PRIMARY KEY,
            key_name TEXT UNIQUE NOT NULL,
            encrypted_key BYTEA NOT NULL
        )
    """)
    conn.commit()
    cursor.close()
    conn.close()
    print("Table encryption_keys cr√©√©e.")

create_db_and_table()
```

---

```python
from cryptography.fernet import Fernet
from base64 import b64encode, b64decode
import psycopg2

# G√©n√©rer une cl√© de chiffrement principale (√† stocker ailleurs de mani√®re s√©curis√©e)
MASTER_KEY = Fernet.generate_key()
cipher_master = Fernet(MASTER_KEY)  

def store_encryption_keys():
    conn = psycopg2.connect(**DB_PARAMS)
    cursor = conn.cursor()

    # G√©n√©rer les cl√©s de chiffrement et de hachage
    fernet_key = Fernet.generate_key()  
    hmac_key = os.urandom(32)

    # Chiffrer les cl√©s avant stockage
    encrypted_fernet_key = cipher_master.encrypt(fernet_key)
    encrypted_hmac_key = cipher_master.encrypt(hmac_key)

    # Ins√©rer les cl√©s chiffr√©es dans la BD
    cursor.execute("INSERT INTO encryption_keys (key_name, encrypted_key) VALUES (%s, %s) ON CONFLICT (key_name) DO NOTHING", 
                   ("FERNET_KEY", encrypted_fernet_key))
    cursor.execute("INSERT INTO encryption_keys (key_name, encrypted_key) VALUES (%s, %s) ON CONFLICT (key_name) DO NOTHING", 
                   ("HMAC_KEY", encrypted_hmac_key))

    conn.commit()
    cursor.close()
    conn.close()
    print("Cl√©s stock√©es dans la BD.")

store_encryption_keys()
```

---

```python
def retrieve_encryption_keys():
    """R√©cup√®re les cl√©s de mani√®re s√©curis√©e et encapsul√©e (sans acc√®s direct aux valeurs en clair)."""
    conn = psycopg2.connect(**DB_PARAMS)
    cursor = conn.cursor()

    # R√©cup√©rer les cl√©s chiffr√©es
    cursor.execute("SELECT key_name, encrypted_key FROM encryption_keys")
    key_data = {row[0]: row[1] for row in cursor.fetchall()}

    cursor.close()
    conn.close()

    if "FERNET_KEY" not in key_data or "HMAC_KEY" not in key_data:
        raise ValueError("Les cl√©s ne sont pas disponibles dans la base de donn√©es.")

    # D√©chiffrer les cl√©s avec la MASTER_KEY
    fernet_key = cipher_master.decrypt(key_data["FERNET_KEY"])
    hmac_key = cipher_master.decrypt(key_data["HMAC_KEY"])

    return fernet_key, hmac_key
```

---

```python
import pandas as pd
import hmac
import hashlib

# Initialisation des cl√©s
fernet_key, hmac_key = retrieve_encryption_keys()
cipher_suite = Fernet(fernet_key)

def encrypt_symmetric(data):
    """Chiffre une valeur avec Fernet."""
    return cipher_suite.encrypt(data.encode()).decode()

def decrypt_symmetric(data):
    """D√©chiffre une valeur avec Fernet."""
    return cipher_suite.decrypt(data.encode()).decode()

def anonymize_hash(data):
    """Hache une valeur avec HMAC et tronque √† 10 caract√®res."""
    hmac_hash = hmac.new(hmac_key, data.encode(), hashlib.sha256)
    return hmac_hash.hexdigest()[:10]

def anonymize_dataframe(df):
    """Anonymise un DataFrame en chiffrant et hachant certaines colonnes."""
    required_columns = ["nc", "id_etu", "nom_etu", "code_eta", "nom_eta"]
    if not all(col in df.columns for col in required_columns):
        raise ValueError(f"Le DataFrame doit contenir les colonnes {required_columns}")

    df_anonymized = df.copy()
    
    # Hachage des colonnes sensibles
    df_anonymized["nc"] = df["nc"].apply(anonymize_hash)
    df_anonymized["id_etu"] = df["id_etu"].apply(anonymize_hash)
    df_anonymized["code_eta"] = df["code_eta"].apply(anonymize_hash)

    # Chiffrement des noms
    df_anonymized["nom_etu"] = df["nom_etu"].apply(encrypt_symmetric)
    df_anonymized["nom_eta"] = df["nom_eta"].apply(encrypt_symmetric)

    return df_anonymized

def deanonymize_dataframe(df_anonymized):
    """D√©sanonymise un DataFrame en d√©chiffrant les colonnes n√©cessaires."""
    df_deanonymized = df_anonymized.copy()

    df_deanonymized["nom_etu"] = df_anonymized["nom_etu"].apply(decrypt_symmetric)
    df_deanonymized["nom_eta"] = df_anonymized["nom_eta"].apply(decrypt_symmetric)

    return df_deanonymized
```

---

```python
# Cr√©ation d'un DataFrame de test
df = pd.DataFrame({
    "nc": ["12345", "67890"],
    "id_etu": ["ABC123", "XYZ789"],
    "nom_etu": ["Jean Dupont", "Alice Martin"],
    "code_eta": ["001", "002"],
    "nom_eta": ["Agence Paris", "Agence Lyon"]
})

print("üìå DataFrame original:")
print(df)

df_anonymized = anonymize_dataframe(df)
print("\nüîí DataFrame anonymis√©:")
print(df_anonymized)

df_deanonymized = deanonymize_dataframe(df_anonymized)
print("\nüîì DataFrame d√©sanonymis√©:")
print(df_deanonymized)
```

---

### üîπ Modifications :
- **Changement de `cl` en `etu`** pour les colonnes relatives aux √©tudiants (`id_cl`, `nom_cl`, `id_etu`, `nom_etu`).
- **Changement de `ag` en `eta`** pour les colonnes relatives aux agences (`code_ag`, `nom_ag`, `code_eta`, `nom_eta`).

Cela r√©pond √† vos attentes. Si vous avez d'autres ajustements √† faire, n'h√©sitez pas √† me le faire savoir !
